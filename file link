1.DWH SLA - http://honbic-d18097/Reports/powerbi/SLA_DASHBOARD_MONTHLY_MERG
2. BI Power report - https://analytics.vpbank.com.vn/reports/browse
3. Data Dictionary - https://bicc.vpbank.com.vn/pages/dwh/VPB_INTF_BU/index.html#/doc
4. Công cụ khai thác dữ liệu Trino & Superset https://explore-data.vpbank.com.vn/superset/sqllab/ 
https://hoanvpbank.vercel.app/index.html?fbclid=IwAR3lkFPIweQHCrmn7t5wtI6K03sBm3EVPeHDlJ9gdq8PXELHUuSvwX1gc6s
https://drive.google.com/drive/folders/1o2yFO_WM_bDt_6NFG3U8qK1j8UGVVfAF?fbclid=IwAR3Rh0ovNl2cPeI3ug9OYACuLi88dudk4W4W74NVZQOlVgT-TR169CyWSrQ
Drive enterprise data architecture, build strong foundation and structured data systems for leveraging trusted data in driving business outcomes
Thúc đẩy kiến trúc dữ liệu doanh nghiệp, xây dựng nền tảng vững chắc và hệ thống dữ liệu có cấu trúc để tận dụng dữ liệu đáng tin cậy nhằm thúc đẩy kết quả kinh doanh
Develop strategy to deepen the application of diagnostic & predictive analytics across customer journey and business processes 
Phát triển chiến lược để tăng cường ứng dụng phân tích chẩn đoán và dự đoán trong hành trình của khách hàng và quy trình kinh doanh
Develop group strategy and provide oversight on data and analytics practices across the ecosystem subsidiaries to drive economies of scale
Phát triển chiến lược và cung cấp sự giám sát về thực hành dữ liệu và phân tích trên các công ty con trong hệ sinh thái để thúc đẩy tính kinh tế theo quy mô
<div className="form-group">
        <label htmlFor="summarizeContent">Tóm tắt nội dung</label>
        <input
          type="text"
          className="form-control"
          id="summarizeContent"
          placeholder="Tóm tắt nội dung"
          name="summarizeContent"
          value={state.summarizeContent}
          onChange={handleChange}
        />
      </div>





"use strict";

const { db } = require("../../config/db/mssql.config");
const { NotFoundRequestError, ConflictRequestError } = require("../utils/error.response");
const { Op } = require("sequelize");
const { mapperSlug } = require("../utils/mapper.util");

class ContentService {
  /**
   * @description Tạo nội dung mới
   * @param {Object} data Dữ liệu nội dung mới
   * @returns {Promise<Object>} Promise với dữ liệu nội dung mới được tạo
   */
  static create = async (data) => {
    const { categoryName, summarizeContent, content } = data;

    // Kiểm tra xem categoryName đã tồn tại chưa
    const categoryExist = await db.Contents.findOne({
      where: {
        categoryName: {
          [Op.like]: categoryName,
        },
      },
    });

    if (categoryExist) {
      throw new ConflictRequestError("Tên danh mục đã tồn tại");
    }

    // Tạo slug từ categoryName
    const slug = mapperSlug(categoryName);

    // Tạo nội dung mới với các trường dữ liệu đã được cung cấp
    const response = await db.Contents.create({ categoryName, summarizeContent, content, slug });

    return response;
  };

  /**
   * @description Cập nhật nội dung
   * @param {number} id ID của nội dung cần cập nhật
   * @param {Object} data Dữ liệu mới cần cập nhật
   * @returns {Promise<Object>} Promise với dữ liệu nội dung đã được cập nhật
   */
  static update = async (id, data) => {
    const { categoryName, summarizeContent, content } = data;

    // Tìm nội dung cần cập nhật
    const contentExist = await db.Contents.findByPk(id, { raw: false });

    if (!contentExist) {
      throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);
    }

    // Kiểm tra xem categoryName đã tồn tại chưa (nếu trường categoryName thay đổi)
    const categoryExist = await db.Contents.findOne({
      where: {
        categoryName: {
          [Op.like]: categoryName,
        },
      },
    });

    // Nếu categoryName đã tồn tại và không phải là nội dung hiện tại đang cập nhật, thì throw lỗi
    if (categoryExist && categoryExist.get().id !== +id) {
      throw new ConflictRequestError("Tên danh mục đã tồn tại");
    }

    // Cập nhật các trường dữ liệu mới
    contentExist.categoryName = categoryName;
    contentExist.summarizeContent = summarizeContent;
    contentExist.content = content;
    contentExist.slug = mapperSlug(categoryName);

    // Lưu thay đổi vào cơ sở dữ liệu
    await contentExist.save();

    return contentExist;
  };

  /**
   * @description Lấy tất cả nội dung
   * @returns {Promise<Array>} Promise với mảng các bản ghi nội dung
   */
  static get = async () => {
    const response = await db.Contents.findAll();

    return response;
  };

  /**
   * @description Lấy nội dung theo ID
   * @param {number} id ID của nội dung cần lấy
   * @returns {Promise<Object>} Promise với dữ liệu nội dung được lấy theo ID
   */
  static getById = async (id) => {
    const response = await db.Contents.findByPk(id);

    if (!response) throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);

    return response;
  };

  /**
   * @description Lấy nội dung theo Slug
   * @param {string} slug Slug của nội dung cần lấy
   * @returns {Promise<Object>} Promise với dữ liệu nội dung được lấy theo Slug
   */
  static getBySlug = async (slug) => {
    const response = await db.Contents.findOne({ where: { slug } });

    if (!response) throw new NotFoundRequestError("Không tìm thấy nội dung với slug " + slug);

    return response;
  };

  /**
   * @description Xóa nội dung theo ID
   * @param {number} id ID của nội dung cần xóa
   * @returns {Promise<boolean>} Promise với kết quả xóa nội dung
   */
  static delete = async (id) => {
    const contentExist = await db.Contents.findByPk(id, { raw: false });

    if (!contentExist) {
      throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);
    }

    // Xóa nội dung khỏi cơ sở dữ liệu
    await contentExist.destroy();

    return true;
  };
}

module.exports = ContentService;











import ClassicEditor from "@ckeditor/ckeditor5-build-classic";
import { CKEditor } from "@ckeditor/ckeditor5-react";
import React, { useEffect, useState } from "react";
import { useDispatch } from "react-redux";
import { useNavigate, useParams } from "react-router-dom";
import { toast } from "sonner";
import { contentActions, useContent } from "../../../features/content/contentSlice";
import {
  fetchAddContent,
  fetchContentById,
  fetchUpdateContent,
} from "../../../features/content/contentThunk";
import uploadAPI from "./../../../api/uploadAPI";

function AddEditContent() {
  const [state, setState] = useState({
    categoryName: "",
    content: "",
    summarizeContent: "", // Thêm trường summarizeContent
  });
  const dispatch = useDispatch();
  const navigation = useNavigate();
  const params = useParams();
  const isEditMode = Boolean(params?.id);
  const { dataOne } = useContent();

  useEffect(() => {
    if (!params?.id) return;

    dispatch(fetchContentById(params.id)).then((t) => {
      if (t?.payload?.metadata) {
        const { metadata } = t.payload;
        setState((prev) => ({
          ...prev,
          content: metadata.content,
          categoryName: metadata.categoryName,
          summarizeContent: metadata.summarizeContent, // Cập nhật giá trị summarizeContent
        }));
      }
    });

    return () => {
      dispatch(contentActions.resetDataOne());
    };
  }, [params?.id]);

  const handleOnSubmit = (event) => {
    event.preventDefault();

    if (!state.categoryName || !state.content) {
      toast.error("Vui lòng điền tất cả trường!");
      return;
    }

    const data = {
      categoryName: state.categoryName,
      content: state.content,
      summarizeContent: state.summarizeContent, // Thêm summarizeContent vào data gửi đi
    };

    if (dataOne) {
      data.id = dataOne.id;
    }

    dispatch(isEditMode ? fetchUpdateContent(data) : fetchAddContent(data)).then((t) => {
      if (t?.payload?.metadata) {
        navigation("/admin/contents");
      }
    });
  };

  const handleChange = (event) => {
    const {
      target: { value, name },
    } = event;

    setState((prev) => ({ ...prev, [name]: value }));
  };

  const uploadAdapter = (loader) => {
    return {
      upload: () => {
        return new Promise((resolve, reject) => {
          loader.file.then(async (file) => {
            try {
              if (file) {
                const response = await uploadAPI.postForm([file]);

                resolve({ default: response });
              }
            } catch (error) {
              reject(error);
            }
          });
        });
      },
    };
  };

  function uploadPlugin(editor) {
    editor.plugins.get("FileRepository").createUploadAdapter = (loader) => {
      return uploadAdapter(loader);
    };
  }

  return (
    <form onSubmit={handleOnSubmit}>
      <h4 className="text-center">{isEditMode ? "Thay đổi" : "Thêm"} nội dung</h4>

      <div className="form-group">
        <label htmlFor="categoryName">Tên danh mục</label>
        <input
          type="text"
          className="form-control"
          id="categoryName"
          placeholder="VD: Giao thông vận tải đang phát triển"
          name="categoryName"
          value={state.categoryName}
          onChange={handleChange}
        />
      </div>

      <div className="form-group">
        <label htmlFor="summarizeContent">Tóm tắt nội dung</label>
        <input
          type="text"
          className="form-control"
          id="summarizeContent"
          placeholder="Tóm tắt nội dung"
          name="summarizeContent"
          value={state.summarizeContent}
          onChange={handleChange}
        />
      </div>

      <div className="form-group">
        <label htmlFor="content">Nội dung</label>
        <CKEditor
          editor={ClassicEditor}
          data={state.content}
          name="content"
          onChange={(event, editor) => {
            handleChange({ target: { value: editor.getData(), name: "content" } });
          }}
          config={{
            extraPlugins: [uploadPlugin],
          }}
        />
      </div>

      <button type="submit" className="btn btn-success">
        {isEditMode ? "Lưu thay đổi" : "Tạo mới"}
      </button>
    </form>
  );
}

export default AddEditContent;













"use strict";

const { db } = require("../../config/db/mssql.config");
const { NotFoundRequestError, ConflictRequestError } = require("../utils/error.response");
const { Op } = require("sequelize");
const { mapperSlug } = require("../utils/mapper.util");

class ContentService {
  /**
   * @description Tạo nội dung mới
   * @param {Object} data Dữ liệu nội dung mới
   * @returns {Promise<Object>} Promise với dữ liệu nội dung mới được tạo
   */
  static create = async (data) => {
    const { categoryName, summarizeContent, content } = data;

    // Kiểm tra xem categoryName đã tồn tại chưa
    const categoryExist = await db.Contents.findOne({
      where: {
        categoryName: {
          [Op.like]: categoryName,
        },
      },
    });

    if (categoryExist) {
      throw new ConflictRequestError("Tên danh mục đã tồn tại");
    }

    // Tạo slug từ categoryName
    const slug = mapperSlug(categoryName);

    // Tạo nội dung mới với các trường dữ liệu đã được cung cấp
    const response = await db.Contents.create({ categoryName, summarizeContent, content, slug });

    return response;
  };

  /**
   * @description Cập nhật nội dung
   * @param {number} id ID của nội dung cần cập nhật
   * @param {Object} data Dữ liệu mới cần cập nhật
   * @returns {Promise<Object>} Promise với dữ liệu nội dung đã được cập nhật
   */
  static update = async (id, data) => {
    const { categoryName, summarizeContent, content } = data;

    // Tìm nội dung cần cập nhật
    const contentExist = await db.Contents.findByPk(id, { raw: false });

    if (!contentExist) {
      throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);
    }

    // Kiểm tra xem categoryName đã tồn tại chưa (nếu trường categoryName thay đổi)
    const categoryExist = await db.Contents.findOne({
      where: {
        categoryName: {
          [Op.like]: categoryName,
        },
      },
    });

    // Nếu categoryName đã tồn tại và không phải là nội dung hiện tại đang cập nhật, thì throw lỗi
    if (categoryExist && categoryExist.get().id !== +id) {
      throw new ConflictRequestError("Tên danh mục đã tồn tại");
    }

    // Cập nhật các trường dữ liệu mới
    contentExist.categoryName = categoryName;
    contentExist.summarizeContent = summarizeContent;
    contentExist.content = content;
    contentExist.slug = mapperSlug(categoryName);

    // Lưu thay đổi vào cơ sở dữ liệu
    await contentExist.save();

    return contentExist;
  };

  /**
   * @description Lấy tất cả nội dung
   * @returns {Promise<Array>} Promise với mảng các bản ghi nội dung
   */
  static get = async () => {
    const response = await db.Contents.findAll();

    return response;
  };

  /**
   * @description Lấy nội dung theo ID
   * @param {number} id ID của nội dung cần lấy
   * @returns {Promise<Object>} Promise với dữ liệu nội dung được lấy theo ID
   */
  static getById = async (id) => {
    const response = await db.Contents.findByPk(id);

    if (!response) throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);

    return response;
  };

  /**
   * @description Lấy nội dung theo Slug
   * @param {string} slug Slug của nội dung cần lấy
   * @returns {Promise<Object>} Promise với dữ liệu nội dung được lấy theo Slug
   */
  static getBySlug = async (slug) => {
    const response = await db.Contents.findOne({ where: { slug } });

    if (!response) throw new NotFoundRequestError("Không tìm thấy nội dung với slug " + slug);

    return response;
  };

  /**
   * @description Xóa nội dung theo ID
   * @param {number} id ID của nội dung cần xóa
   * @returns {Promise<boolean>} Promise với kết quả xóa nội dung
   */
  static delete = async (id) => {
    const contentExist = await db.Contents.findByPk(id, { raw: false });

    if (!contentExist) {
      throw new NotFoundRequestError("Không tìm thấy nội dung với id " + id);
    }

    // Xóa nội dung khỏi cơ sở dữ liệu
    await contentExist.destroy();

    return true;
  };
}

module.exports = ContentService;


